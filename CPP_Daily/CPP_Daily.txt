PCALL - Preprocessor , Compiler , Assembler , Linker , Loader
isoeR

Command to run CPP Program - 
g++ hello.cpp -o hello.exe
hello.exe
--------------------------
Que. linker links main.o and .lib/.dll or .so filer into a.exe but what are these .lib / .dll /.so files?
`.lib`, `.dll`, and `.so` files are types of libraries used in C++ development:

- **.lib** (Static Library or Import Library, Windows):  
  Contains compiled code that can be linked directly into your executable at build time. If you use a static `.lib`, its code becomes part of your `.exe`.

- **.dll** (Dynamic Link Library, Windows):  
  Contains compiled code that is loaded at runtime. Your program uses an import `.lib` to know how to call functions in the `.dll`, but the actual code stays in the `.dll` and is loaded when your program runs.

- **.so** (Shared Object, Linux/Unix):  
  Similar to `.dll`, but used on Linux/Unix systems. It contains code that is loaded dynamically at runtime.

***
These files provide reusable code (functions, classes, etc.) that you can use in your programs without having to write everything yourself.
example -#include <iostream> // Reusable code for input/output
--------------------------------------------------------------------------------------------------------

# Datatypes
1.Fundamental
2.Derived
3.User Defined

---------------------------------------------

***Member function do not get space inside object.  But variables do


Que. Why pointers are used in C but not in C++ struct with member functions
First code (C) uses pointers because functions are separate from the struct; passing pointers is needed to modify the original struct data.

Second code (C++ style) embeds functions inside the struct; functions can directly modify the struct's own data members using this pointer implicitly, so no explicit pointer parameter is needed.

What to use in C -
Declare structs to hold data only.
Use separate functions taking struct pointers to operate on the data.

What to use in C++ -
Use structs or classes with member functions inside.
Call functions on struct objects directly.
----------------------------------------------------------------------------------------------------
Remember Syntax
emp.Employee::printRecord( ); //message passing 


-----------------------------
Never forgot to write 

using namespace "namespace_name"
or access variable in namespace using :: (Scope Resolution Operator)
--------------------------------------------------------------------------
//typedef is used to create the alias for existing data type (class / structure)
//reference is used to create alias of existing object


-------------------------------------------------------------------------------
Que. Why malloc return type is void* ?
// void* malloc(size_t size); 

malloc(size_t size) means: “Give me a block of memory of size bytes.”

But malloc doesn’t know what you want to store there (int? float? struct?).

That’s why it returns a generic pointer → void*.

👉 A void* pointer in C means:

"This is a pointer to some memory, but I don't know the data type yet."
So after malloc, you decide the type by typecasting it.

Syntax -

int *p = (int*) malloc(5 * sizeof(int));   // memory for 5 integers
float *q = (float*) malloc(10 * sizeof(float)); // memory for 10 floats

🔹 free(ptr);

When you call malloc, memory is given from the heap.

That memory will not be automatically released when the function ends.

If you keep allocating and never release → memory leak (program wastes memory).

👉 free(ptr); tells the system:

"I’m done using this memory, you can take it back."

So after free(ptr);

The memory block in the heap (that stored 100) is returned to the OS.

But the pointer ptr still holds the old address (like 1000 in your diagram).

This makes it a dangling pointer → dangerous if you accidentally use it.

🔹 ptr = NULL;

After free, ptr is still pointing to freed memory.

Accessing it (*ptr) would be undefined behavior.

Setting ptr = NULL; makes it safe.

-----------------------------------------------------------------------
Dynamic Allocation in C

 int *ptr = new int; 

🔹 What happens here

new int → asks the system for memory in the heap for one integer.

It returns the address of that memory (just like malloc).

ptr (an int*) will store that address.

So now ptr points to a heap location that can store 1 integer.

## Some other Syntaxes -

//int *ptr = new int; // Default value garbage; 
    
//int *ptr = new int( ); // default value 0 

//int *ptr = new int(3);  // value at ptr = 3


## Array of Integers

//int *ptr = new int[3]; //12 bytes //here default will be garbage

int *ptr = new int[3](); //12 bytes //here default value 0


## Syntax for 2D array

----Array of Pointers-----
// int **ptr = (int**)calloc(4 , sizeof(int*));

// int **ptr = new int *[4];



----------------------------------------------------------------------
DAY 5

Association -(has-a) relationship

1. Composition - Tight Coupling 
	
2. Aggregation - Loose Coupling

class Date {

	//TODO
};

class Employee{

	Date joindate; //Here we create object inside object (object will compulsorily get space inside Employee class) Therefore Tight Coupling 

	Date *joindate; //Here we created pointer , object is not stored inside object of Employee , this will be somewhere in heap memory(Loose Coupling)

};


---------------------



#Inheritance

- is a relationship

- Also called as GENERALISATION
- Inheritance is a journey form GENERALIZATION TO SPECIALIZATION

- In C++, default mode of inheritance is private

- All the non static data members of base class get space inside object of derived class. In other words, non static data members of base class, inherit into derived class.

- Using derived class, we can access static members of base class. In other words, static data members of base class, inherit into derived class

- All the data members( static/non static) of base class of any access specifier(private/protected/public), inherit into derived class but only non static data member get space inside object

- Size of object of Base class = size of of all the non static data members declared in base class.

- Size of object of Derived class = size of of all the non static data members declared in base class + size of of all the non static data members declared in derived class.

- Static and Non static member functions are inherited into derived class



Following function do not inherit into derived class:

1.Constructor

2.Destructor

3.Copy constructor

4.Assignment operator function

5.Friend function



* If we create object of derived class then first base class constructor gets called and then derived class constructor gets called. Destructor calling sequence is exactly opposite.
* From any constructor of derived class, by default, base class's parameterless constructor gets called
* If we want to call, any constructor of base class from constructor of derived class then we should use constructor's base initializer list.
(Day5_4.cpp)




# TYPES OF INHERITANCE - 



1. Implementation Inheritance 
2. Interface Inheritance



Both has 
1. Single Inheritance

2. Multiple Inheritance

3. Hierarchical Inheritance

4. Multilevel Inheritance




# Shadowing (Day5_9.cpp)

If name of base class and derived class member function is same and if we try to call such member function on object of derived class then preference is given to the derived class member function. **Here derived class member function hides implementation of inherited function**. This process is called shadowing.

Without changing implementation of existing class, if we want to extend meaning of that class then we should use inheritance


#DIAMOND PROBLEM

1.During diamond inheritance, data members of indirect base class inherit into indirect derived class multiple times. Hence it affects on size of object of indirect derived class.
2.During diamond inheritance, member function of indirect base class inherit into indirect derived class multiple times. If we try to call member function of indirect base class on object of indirect derived class, compiler generates ambiguity error.
3.During diamond inheritance, if we create object of indirect derived class the constructor and destructor of indirect base class gets called multiple times.


If we want to avoid diamond problem then we should declare base class virtual. ****

two pointers in B and C are added when be declare Indirect Base class as virtual , One in B and One in C
It decreases the size of Indirect Derived Class 
(When we create more )


-----------------------------------------------------------------------

-----------Day 6-----------

# Created Dynamic Object using pointer and new keyword	
int main()
{
    Base *ptrBase = new Base( ); 
    //ptrBase->printRecord( ); //Base::printRecord()
    //ptrBase->showRecord( ); //Base::showRecord()
    //ptrBase->Derived::displayRecord(); //we cannot call derived  class members on base class object 
    //ptrBase->Derived::printRecord( ); //we cannot call derived  class members on base class object 
    return 0;
}
------------------------------------------------------------------------------------------------

int main5()
{   //Here we pass base class base class object parameters to another base class object 
    Base b1(10,20);
    Base b2;  //There is difference between assignment and initialization
    b2 = b1;  //Here we assign parameters of b1 to b2 object
    b2.printRecord( ); 
    return 0;
}

int main6()
{   //Here we passed derived class object parameters to another derived class object
    Derived d1(10,20,30); 
    Derived d2; 
    d2 = d1; 
    d2.displayRecord( );  
    return 0;
}

# Object Slicing -
If we assign , derieved class object to the base class object then compiler considers
only base class members from derieved class object and copy it into base class object.

During object slicing mode of inheritance should be public

int main7()
{   //If we assign , derieved class object to the base class object then compiler considers
    //only base class members from derieved class object and copy it into base class object.
    Derived d1(10,20,30); 
    Base b1; 
    b1 = d1; 
    b1.printRecord( ); 
    return 0;
}


#UPCASTING- 

Process of converting pointer of derived class into pointer of base class is Upcasting

int main8()
{
    Derived *ptrDerived = new Derived(10,20,30); 
    //ptrDerived->printRecord( ); //10 20 30  
    //Base *ptrBase = (Base*)ptrDerived; // upcasting 
    Base *ptrBase = ptrDerived; // upcasting ( casting is optional )
    //ptrBase->printRecord( ); //10 20  
    ptrDerived = (Derived*)ptrBase; // downcasting 
    ptrDerived->printRecord( ); //10 20 30   
    return 0;
}

 
--UPCASTING IN SINGLE LINE and DOWNCASTING
int main9()
{
    Base *ptrBase = new Derived(10,20,30);//upcasting  in single line
    //ptrBase->printRecord( ); //10 20   
    Derived *ptrDerived = (Derived*)ptrBase; //downcasting 
    ptrDerived->printRecord( ); 
    return 0;
} 

# DOWNCASTING -
Process of converting pointer of base class into pointer of derived class is Downcasting


--WITHOUT UPCASTING YOU CANNOT PERFORM DOWNCASTING , IF YOU WANT TO DOWNCAST WE COMPULSARILY FIRST UPCAST
int main10()
{
    Base *ptrBase = new Base(10,20); 
    ptrBase->printRecord( ); 
    Derived *ptrDerived = (Derived*)ptrBase;
    ptrDerived->printRecord( );  
    return 0;
}


Que What is the need of creating object dynamically , if we can create it on compile time ?
=>

-------------
# Use of UPCASTIING - (PRACTICAL APPLICATION)

Book *book
Tape *tape
.
.
.
.

If there are 1000 products we need to create 1000 pointers //NOT OK        (Day6_5.cpp)

We can use UPCASTING and create only one pointer of Product class          (Day6_6.cpp)
and copy the address of Derived class object into Base Class Pointer //OK

int main()
{
    int choice; 
    while((choice = ::menulist())!=0)
    {
        Product *ptr = NULL;  //USED ONLY ONE POINTER 
        switch (choice)
        {
        case 1: 
            ptr = new Book( ); // upcasting 
            ptr->acceptRecord( ); 
            ptr->printRecord( ); 
            break;
        case 2: 
            ptr = new Tape( );  //upcasting 
            ptr->acceptRecord( ); 
            ptr->printRecord( ); 
        }
        delete ptr; 
        ptr = NULL; 
    }
    return 0;
}

(Day6_7.cpp) ---> we made code compact , BUT 

There is problem , it is calling Products class accept and print 
pagecount , playtime is getting ignored from book and tape class

Product * ptr ------------> this is where problem is occurring , COMPILER IS SEEING THE TYPE OF POINTER which is Product , so it will call Products class accept and print 

//Rather than looking at the type of object compiler checks the type of pointer  . THIS IS CALLED "EARLY BINDING"


So, we use "virtual" keyword in accept and print member functions of Products class ("VIRTUAL KEYWORD")
It will now behave according to object and will take accept , print of object

now pagecount and playtime will be considered;

---------------------------------------------------------------------

# FUNCTION OVERRIDING -

- Process of redefining "virtual" function of the base class inside derived class with the same signature is called "FUNCTION OVERRIDING"

# RUN TIME POLYMORPHISM / DYNAMIC METHOD DISPATCH

- By using base class pointer we call derived class member functions . This process is called Run Time Polymorphism.

# FOR FUNCTION OVERRIDING - (ONLY VIRTUAL FUNCTIONS ARE OVERRIDDEN)***

1. Function must be inside base and derived class too
2. Signature of base class function and derived class function must be same
3. Atlest function in Base class must be "virtual" 
-------------------

# VIRTUAL FUNCTION -
- function with virtual keyword 
- In case of upcasting, a function, which gets called depending on type of object rather than type of pointer is called virtual function.
- If we are performing Overriding means same signature function in both base and derived class and if we declare member function of base class as virtual then derived class member function 	is taken into consideration
# POLYMORPHIC CLASS -
	class with atleast one virtual function is Polymorphic class

*** Constructor cannot be virtual
*** Static Member function cannot be virtual 
Hence cannot be Overridden
-----------------------------------------
# ABSTRACT METHOD -

virtual void acceptRecord(void) = 0;

Function with "virtual" keyword and no body initialized with 0 (PURE VIRTUAL FUNCTION)

Que. If we dont use virtual like [ void acceptRecord(void) =0; ] and initialized with 0,  Is it correct ?
=> If we declare like [ void acceptRecord(void) = 0 ] it cannot be overridden until its declared virtual 
   and function like [ void acceptRecord(void) = 0 ] is of no use

# ABSTRACT CLASS -

- If our class contain atleast one Abstract method/ Pure Virtual function then it is Abstract class
- Overriding virtual function is not mandatory , but overriding pure virtual function is mandatory
- If not then Derived class also be Abstract

# Interface -

- If class has all pure virtual functions then it is call pure abstract class / Interface .

# Interface Inheritance 

- Inheritance between Interfaces is called as Interface Inheritance

# Design Pattern - 

1. Factory Method
2. Singelton Method

# Typeid
#RTTI(RunTime Type Information)


------------------------------------------------------------------------------------------------------------------------------
> Day 2 Revision

1.Scope Resolution Operator
2.Need of Namespace
3.Nested Namespace
4."using" directive
5.Points to remember about namespace
6.Standard Streams of c++
7.Manipulator
8.Charecteristics of object
9.Empty Class (size of empty class is 1 byte)
10.Class (dont get space in memory),(Logical entity)
11.Object (gets space in memory),(Physical entity)
12.Function Overloading
13.this pointer =>
If we call member function on object compiler implicitly pass , address of current object as a argument to function
To store that address of argument compiler implicitly generates one pointer as a function parameter inside member function. This is called this pointer
- Present in only nonstatic member function
- G,F,S dont get this pointer (Global,Friend,Static) functions
14.Inline Function

-------------
------------Day 7----------

# During upcasting, if we want to access:

1.Data members of derived class
2.Non overridden function of derived class 

=> then we should use down casting.


# typeid -
typeid is a function defined in typeinfo header file 
It returns the reference object of typeinfo class  

eg - typeid(baseptr)

//cout<<typeid(shape).name()<<endl;    P5Shape (Pointer -> P , character_count -> 5 , actual_character(typename) -> shape )
//cout<<typeid(*shape).name()<<endl;   9Rectangle ( character_count -> 5 , actual_character(typename) -> shape )



--------------------------------------------------------
-----------Day 8--------------

# C++ Vectors
- A vector in C++ is like a resizable array.
- Both vectors and arrays are data structures used to store multiple elements of the same data type.
- The difference between an array and a vector, is that the size of an array cannot be modified (you cannot add or remove elements from an array). A vector however, can grow or shrink in size as needed.

- Create a vector called cars that will store strings: 
eg - vector<string> cars = {"Volvo", "BMW", "Ford", "Mazda"};

// Print vector elements
for (string car : cars) {
  cout << car << "\n";
}


-->> Operation on vector
1. push_back
2. pop_back
3. push_front
4. pop_front
5. begin
6. end
7. erase

# Iterator for traversing Vector ->

 for(vector<int> :: iterator itr = v1.begin() ; itr!=v1.end() ; itr++)
        cout<<*itr<<endl; 

--------------------------------------------------------------------------	

Day 5

# Association
1.Composition
2.Aggregation



Day 6

#Object Slicing
#Upcasting
#Downcasting
#Virtual Function
#Function overriding
#Polymorphism - Process of calling member function of derived class using pointer of base class is called runtime Polymorphism.




